package main

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"
)

var (
	hooksAll       bool
	hooksSecrets   bool
	hooksImpact    bool
	hooksPreCommit bool // Use pre-commit framework
)

var setupHooksCmd = &cobra.Command{
	Use:   "hooks",
	Short: "Install git hooks for CKB",
	Long: `Install git hooks to run CKB checks automatically.

Available hooks:
  - secrets: Scan staged files for exposed secrets (blocks commit if found)
  - impact: Analyze impact of changes (warns on high-risk changes)

Examples:
  # Interactive selection (prompts for which hooks to install)
  ckb setup hooks

  # Install all hooks
  ckb setup hooks --all

  # Install only secret scanning hook
  ckb setup hooks --secrets

  # Install for use with pre-commit framework
  ckb setup hooks --pre-commit`,
	Run: runSetupHooks,
}

func init() {
	setupHooksCmd.Flags().BoolVar(&hooksAll, "all", false, "Install all available hooks")
	setupHooksCmd.Flags().BoolVar(&hooksSecrets, "secrets", false, "Install secret scanning hook")
	setupHooksCmd.Flags().BoolVar(&hooksImpact, "impact", false, "Install impact analysis hook")
	setupHooksCmd.Flags().BoolVar(&hooksPreCommit, "pre-commit", false, "Generate .pre-commit-config.yaml instead of git hooks")

	// Add as subcommand to setup
	setupCmd.AddCommand(setupHooksCmd)
}

func runSetupHooks(cmd *cobra.Command, args []string) {
	repoRoot := mustGetRepoRoot()
	gitDir := filepath.Join(repoRoot, ".git")

	// Verify we're in a git repo
	if _, err := os.Stat(gitDir); os.IsNotExist(err) {
		fmt.Fprintln(os.Stderr, "Error: Not a git repository")
		os.Exit(1)
	}

	// If using pre-commit framework, generate YAML config
	if hooksPreCommit {
		generatePreCommitConfig(repoRoot)
		return
	}

	// Determine which hooks to install
	installSecrets := hooksAll || hooksSecrets
	installImpact := hooksAll || hooksImpact

	// If no specific flags, default to secrets only
	if !installSecrets && !installImpact {
		installSecrets = true
	}

	hooksDir := filepath.Join(gitDir, "hooks")
	if err := os.MkdirAll(hooksDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating hooks directory: %v\n", err)
		os.Exit(1)
	}

	preCommitPath := filepath.Join(hooksDir, "pre-commit")

	// Check if hook already exists
	existingHook := ""
	if data, err := os.ReadFile(preCommitPath); err == nil {
		existingHook = string(data)
	}

	// Build new hook content
	hookContent := buildPreCommitHook(installSecrets, installImpact, existingHook)

	// Write hook
	if err := os.WriteFile(preCommitPath, []byte(hookContent), 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing pre-commit hook: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Installed git hooks:")
	if installSecrets {
		fmt.Println("  - pre-commit: Secret scanning (blocks on findings)")
	}
	if installImpact {
		fmt.Println("  - pre-commit: Impact analysis (warns on high risk)")
	}
	fmt.Printf("\nHook installed at: %s\n", preCommitPath)
}

func buildPreCommitHook(secrets, impact bool, existing string) string {
	// Start with shebang
	hook := "#!/bin/bash\n"
	hook += "# CKB pre-commit hooks\n"
	hook += "# Generated by: ckb setup hooks\n\n"

	// If there's existing content that's not ours, preserve it
	if existing != "" && !isOurHook(existing) {
		hook += "# --- Existing hook content ---\n"
		// Strip shebang from existing
		existingContent := existing
		if len(existingContent) > 2 && existingContent[:2] == "#!" {
			if idx := indexOf(existingContent, "\n"); idx != -1 {
				existingContent = existingContent[idx+1:]
			}
		}
		hook += existingContent
		hook += "\n# --- End existing hook content ---\n\n"
	}

	hook += "# --- CKB checks ---\n\n"

	if secrets {
		hook += secretsHookScript()
	}

	if impact {
		hook += impactHookScript()
	}

	hook += "# --- End CKB checks ---\n"
	return hook
}

func secretsHookScript() string {
	return `# Secret scanning
echo "Running CKB secret scan..."
if command -v ckb &> /dev/null; then
    result=$(ckb scan-secrets --scope=staged --min-severity=high --output=json 2>/dev/null)
    findings=$(echo "$result" | jq -r '.summary.totalFindings // 0' 2>/dev/null)

    if [ "$findings" -gt 0 ]; then
        echo ""
        echo "ERROR: $findings secret(s) detected in staged files!"
        echo ""
        ckb scan-secrets --scope=staged --min-severity=high --output=human
        echo ""
        echo "Please remove secrets before committing."
        echo "If this is a false positive, add to .ckb/secrets-allowlist.json"
        exit 1
    fi
else
    echo "Warning: ckb not found, skipping secret scan"
fi

`
}

func impactHookScript() string {
	return `# Impact analysis
echo "Running CKB impact analysis..."
if command -v ckb &> /dev/null; then
    result=$(ckb impact diff --staged --format=json 2>/dev/null)
    risk=$(echo "$result" | jq -r '.riskScore.level // "unknown"' 2>/dev/null)

    if [ "$risk" = "critical" ]; then
        echo ""
        echo "WARNING: This commit has CRITICAL risk level"
        echo ""
        ckb impact diff --staged --format=human
        echo ""
        read -p "Continue with commit? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    elif [ "$risk" = "high" ]; then
        echo "Note: This commit has high risk level"
        ckb impact diff --staged --format=human 2>/dev/null | head -20
    fi
fi

`
}

func generatePreCommitConfig(repoRoot string) {
	configPath := filepath.Join(repoRoot, ".pre-commit-config.yaml")

	// Check if file exists
	if _, err := os.Stat(configPath); err == nil {
		fmt.Fprintln(os.Stderr, "Warning: .pre-commit-config.yaml already exists")
		fmt.Fprintln(os.Stderr, "Add the following to your existing config:")
		fmt.Println()
	}

	config := `# CKB pre-commit hooks
# Add to your .pre-commit-config.yaml

repos:
  - repo: local
    hooks:
      - id: ckb-secrets
        name: CKB Secret Scan
        entry: bash -c 'result=$(ckb scan-secrets --scope=staged --min-severity=high --output=json 2>/dev/null); findings=$(echo "$result" | jq -r ".summary.totalFindings // 0" 2>/dev/null); if [ "$findings" -gt 0 ]; then echo "Secrets detected!"; ckb scan-secrets --scope=staged --output=human; exit 1; fi'
        language: system
        stages: [commit]
        pass_filenames: false

      - id: ckb-impact
        name: CKB Impact Analysis
        entry: bash -c 'result=$(ckb impact diff --staged --format=json 2>/dev/null); risk=$(echo "$result" | jq -r ".riskScore.level // \"unknown\"" 2>/dev/null); if [ "$risk" = "critical" ] || [ "$risk" = "high" ]; then echo "High-risk changes detected:"; ckb impact diff --staged --format=human | head -30; fi'
        language: system
        stages: [commit]
        pass_filenames: false
        verbose: true
`
	fmt.Println(config)

	// If file doesn't exist, offer to create it
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		if err := os.WriteFile(configPath, []byte(config), 0644); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing config: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("\nCreated: %s\n", configPath)
		fmt.Println("Run 'pre-commit install' to activate hooks")
	}
}

func isOurHook(content string) bool {
	return indexOf(content, "CKB pre-commit hooks") != -1 ||
		indexOf(content, "ckb scan-secrets") != -1
}

func indexOf(s, substr string) int {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return i
		}
	}
	return -1
}
