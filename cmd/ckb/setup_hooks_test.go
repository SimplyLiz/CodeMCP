package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestBuildPreCommitHook(t *testing.T) {
	// Test with secrets only
	hook := buildPreCommitHook(true, false, "")
	if !strings.Contains(hook, "#!/bin/bash") {
		t.Error("Hook should start with bash shebang")
	}
	if !strings.Contains(hook, "ckb scan-secrets") {
		t.Error("Hook should contain scan-secrets command")
	}
	if strings.Contains(hook, "ckb impact") {
		t.Error("Hook should not contain impact command when impact=false")
	}

	// Test with impact only
	hook2 := buildPreCommitHook(false, true, "")
	if !strings.Contains(hook2, "ckb impact") {
		t.Error("Hook should contain impact command")
	}
	if strings.Contains(hook2, "ckb scan-secrets") {
		t.Error("Hook should not contain scan-secrets when secrets=false")
	}

	// Test with both
	hook3 := buildPreCommitHook(true, true, "")
	if !strings.Contains(hook3, "ckb scan-secrets") {
		t.Error("Hook should contain scan-secrets command")
	}
	if !strings.Contains(hook3, "ckb impact") {
		t.Error("Hook should contain impact command")
	}
}

func TestBuildPreCommitHookPreservesExisting(t *testing.T) {
	existingHook := `#!/bin/bash
# My custom hook
echo "Running custom checks"
npm test
`

	hook := buildPreCommitHook(true, false, existingHook)

	// Should preserve existing content
	if !strings.Contains(hook, "npm test") {
		t.Error("Should preserve existing hook content")
	}
	if !strings.Contains(hook, "Running custom checks") {
		t.Error("Should preserve existing hook comments")
	}

	// Should still add CKB checks
	if !strings.Contains(hook, "ckb scan-secrets") {
		t.Error("Should add CKB scan-secrets")
	}
}

func TestBuildPreCommitHookSkipsOurContent(t *testing.T) {
	// If existing hook is already ours, don't duplicate
	existingHook := `#!/bin/bash
# CKB pre-commit hooks
# Generated by: ckb setup hooks

# Secret scanning
echo "Running CKB secret scan..."
ckb scan-secrets --scope=staged --min-severity=high
`

	hook := buildPreCommitHook(true, false, existingHook)

	// Should not have duplicate markers
	count := strings.Count(hook, "CKB pre-commit hooks")
	if count > 1 {
		t.Errorf("Should not duplicate CKB markers, found %d", count)
	}
}

func TestIsOurHook(t *testing.T) {
	testCases := []struct {
		content string
		want    bool
	}{
		{"#!/bin/bash\n# CKB pre-commit hooks\n", true},
		{"#!/bin/bash\nckb scan-secrets --scope=staged\n", true},
		{"#!/bin/bash\nnpm test\n", false},
		{"#!/bin/bash\necho 'hello'\n", false},
	}

	for _, tc := range testCases {
		got := isOurHook(tc.content)
		if got != tc.want {
			t.Errorf("isOurHook(%q) = %v, want %v", tc.content[:20]+"...", got, tc.want)
		}
	}
}

func TestIndexOf(t *testing.T) {
	testCases := []struct {
		s      string
		substr string
		want   int
	}{
		{"hello world", "world", 6},
		{"hello world", "hello", 0},
		{"hello world", "foo", -1},
		{"", "foo", -1},
		{"hello", "", 0},
	}

	for _, tc := range testCases {
		got := indexOf(tc.s, tc.substr)
		if got != tc.want {
			t.Errorf("indexOf(%q, %q) = %d, want %d", tc.s, tc.substr, got, tc.want)
		}
	}
}

func TestSecretsHookScript(t *testing.T) {
	script := secretsHookScript()

	// Should check for ckb availability
	if !strings.Contains(script, "command -v ckb") {
		t.Error("Script should check for ckb command")
	}

	// Should scan staged files
	if !strings.Contains(script, "--scope=staged") {
		t.Error("Script should scan staged files")
	}

	// Should use high severity minimum
	if !strings.Contains(script, "--min-severity=high") {
		t.Error("Script should use high severity minimum")
	}

	// Should exit 1 on findings
	if !strings.Contains(script, "exit 1") {
		t.Error("Script should exit 1 when secrets found")
	}

	// Should suggest allowlist for false positives
	if !strings.Contains(script, "secrets-allowlist.json") {
		t.Error("Script should mention allowlist for false positives")
	}
}

func TestImpactHookScript(t *testing.T) {
	script := impactHookScript()

	// Should check for ckb availability
	if !strings.Contains(script, "command -v ckb") {
		t.Error("Script should check for ckb command")
	}

	// Should analyze staged changes
	if !strings.Contains(script, "--staged") {
		t.Error("Script should analyze staged changes")
	}

	// Should check risk level
	if !strings.Contains(script, "riskScore.level") || !strings.Contains(script, "risk") {
		t.Error("Script should check risk level")
	}

	// Should warn on critical
	if !strings.Contains(script, "critical") {
		t.Error("Script should handle critical risk level")
	}
}

func TestGeneratePreCommitConfig(t *testing.T) {
	// Create temp directory
	tmpDir, err := os.MkdirTemp("", "hooks-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Capture stdout by redirecting
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	generatePreCommitConfig(tmpDir)

	w.Close()
	os.Stdout = oldStdout

	// Read captured output
	buf := make([]byte, 4096)
	n, _ := r.Read(buf)
	output := string(buf[:n])

	// Should contain pre-commit framework config
	if !strings.Contains(output, "repos:") {
		t.Error("Should output pre-commit repos config")
	}
	if !strings.Contains(output, "ckb-secrets") {
		t.Error("Should contain ckb-secrets hook")
	}
	if !strings.Contains(output, "ckb-impact") {
		t.Error("Should contain ckb-impact hook")
	}

	// Should create the file
	configPath := filepath.Join(tmpDir, ".pre-commit-config.yaml")
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		t.Error("Should create .pre-commit-config.yaml file")
	}
}

func TestGeneratePreCommitConfigExisting(t *testing.T) {
	// Create temp directory with existing config
	tmpDir, err := os.MkdirTemp("", "hooks-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create existing config
	configPath := filepath.Join(tmpDir, ".pre-commit-config.yaml")
	existingContent := "repos:\n  - repo: existing\n"
	if err := os.WriteFile(configPath, []byte(existingContent), 0644); err != nil {
		t.Fatalf("Failed to write existing config: %v", err)
	}

	// Capture stderr for warning
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	// Capture stdout
	oldStdout := os.Stdout
	rOut, wOut, _ := os.Pipe()
	os.Stdout = wOut

	generatePreCommitConfig(tmpDir)

	w.Close()
	wOut.Close()
	os.Stderr = oldStderr
	os.Stdout = oldStdout

	// Read stderr
	buf := make([]byte, 1024)
	n, _ := r.Read(buf)
	stderr := string(buf[:n])

	// Should warn about existing file
	if !strings.Contains(stderr, "already exists") {
		t.Error("Should warn about existing config file")
	}

	// Should not overwrite existing file
	content, _ := os.ReadFile(configPath)
	if string(content) != existingContent {
		t.Error("Should not overwrite existing config")
	}

	// Read and discard stdout
	bufOut := make([]byte, 4096)
	rOut.Read(bufOut)
}
