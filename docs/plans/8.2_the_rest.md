# CKB v8.2: AI Workflow Optimization

**Theme:** Close the feedback loop. Help AI agents understand *what went wrong* after they act.

**Origin:** Analysis of AI coding agent workflow bottlenecks (January 2026). Research into MCP ecosystem tools and context management challenges revealed that while CKB v8.0 solves 70% of AI efficiency problems (pre-action understanding), the remaining gap is post-action feedback: build errors, failure diagnosis, and proactive context injection.

---

## Problem Statement

### Current State

CKB excels at helping AI agents understand code *before* they act:
- `explore` / `understand` → codebase orientation
- `prepareChange` → impact analysis before modification
- `getAffectedTests` → what tests to run

### The Gap

AI agents struggle *after* they act:
- Build fails → agent reads raw compiler output, manually correlates to symbols
- Test fails → agent greps through output, doesn't know which recent change caused it
- Unexpected behavior → agent re-explores the same wrong paths ("context poisoning")

### Research Findings

From industry analysis (VentureBeat, Towards Data Science, Anthropic best practices):

> "Context is the bottleneck, not model capability."

> "Context poisoning — when an agent spends thousands of tokens exploring a wrong solution path, it has difficulty ignoring that bad exploration even when explicitly redirected."

Key insight: Every tool call an AI makes to grep/glob/read could be one semantic query to a pre-indexed system. CKB provides this for *understanding* code, but not for *understanding failures*.

---

## v8.2 Features

### 1. Build Error → Symbol Correlation

**Problem:** Build errors reference file:line, but AI agents don't automatically know which CKB symbol that corresponds to, who calls it, or how to fix it.

**Tool:** `parseBuildErrors`

```json
// Input
{
  "output": "src/auth/handler.go:42:15: undefined: ValidateToken",
  "format": "auto"  // "auto" | "go" | "typescript" | "python" | "rust" | "generic"
}

// Output
{
  "errors": [
    {
      "file": "src/auth/handler.go",
      "line": 42,
      "column": 15,
      "message": "undefined: ValidateToken",
      "symbolId": "ckb:repo:sym:abc123",  // resolved symbol at this location
      "symbolName": "HandleLogin",
      "missingReference": {
        "name": "ValidateToken",
        "candidates": [
          {
            "symbolId": "ckb:repo:sym:def456",
            "location": "src/auth/validation.go:18",
            "confidence": 0.92,
            "reason": "Name match, same package"
          }
        ]
      },
      "callersAffected": 12,
      "suggestedFix": "Import 'ValidateToken' from auth/validation or check if it was renamed"
    }
  ],
  "cascadeRisk": "medium",
  "summary": "1 undefined symbol, likely missing import or rename"
}
```

**Implementation:**
1. Parse build output using language-specific patterns
2. Map file:line to symbol via SCIP index
3. For "undefined" errors, search for candidate symbols by name
4. Calculate cascade risk based on caller count
5. Generate suggested fixes based on error type

**Language Support:**
| Language | Error Pattern Detection |
|----------|------------------------|
| Go | `file:line:col: message` |
| TypeScript | `file(line,col): error TS*` |
| Python | `File "path", line N` + traceback |
| Rust | `error[E*]: message` + location |
| Generic | Line-based heuristics |

**Value:** High — AI agents currently waste 3-5 tool calls correlating build errors to code.

**Effort:** Medium — pattern matching + symbol resolution.

---

### 2. "Why Did This Break?" Debugger

**Problem:** When something breaks after a change, AI agents re-explore the codebase without knowing *what changed* that might have caused it.

**Tool:** `diagnoseFailure`

```json
// Input
{
  "error": "undefined method 'validate' for nil:NilClass",
  "file": "app/models/user.rb",
  "line": 42,
  "context": "optional additional context from agent"
}

// Output
{
  "likelyCause": {
    "confidence": 0.85,
    "explanation": "UserValidator was renamed to AccountValidator in commit abc123 (2 hours ago)",
    "commit": "abc123",
    "author": "alice",
    "symbolChanged": {
      "old": "UserValidator",
      "new": "AccountValidator",
      "symbolId": "ckb:repo:sym:xyz789"
    }
  },
  "relatedChanges": [
    {
      "commit": "abc123",
      "message": "Rename UserValidator to AccountValidator",
      "filesChanged": ["app/validators/account_validator.rb"],
      "symbolsChanged": ["ckb:repo:sym:xyz789"],
      "age": "2h"
    }
  ],
  "affectedLocations": [
    {
      "file": "app/models/user.rb",
      "line": 42,
      "stillReferences": "UserValidator",
      "shouldReference": "AccountValidator"
    }
  ],
  "suggestedFix": "Update reference at app/models/user.rb:42 from 'UserValidator' to 'AccountValidator'",
  "alternativeExplanations": [
    {
      "confidence": 0.15,
      "explanation": "Nil check missing on line 40"
    }
  ]
}
```

**Implementation:**
1. Parse error to identify affected symbol/location
2. Query recent git history for changes to related symbols
3. Use symbol alias chains to detect renames
4. Cross-reference with `analyzeCoupling` to find historically co-changed files
5. Rank explanations by recency + relevance
6. Generate actionable fix suggestion

**Key differentiator:** Uses CKB's existing symbol tracking + git integration to *explain* failures, not just locate them.

**Value:** High — eliminates "context poisoning" from wrong-path exploration.

**Effort:** Medium — combines existing primitives (git, symbols, coupling).

---

### 3. Proactive Context Triggers

**Problem:** AI agents start every task by exploring. CKB waits passively for queries instead of proactively providing relevant context.

**Feature:** Context trigger system

```yaml
# .ckb/triggers.yaml
triggers:
  # When working on auth, proactively provide ownership and security context
  - name: auth-context
    when:
      file_matches: "**/auth/**"
    inject:
      - tool: getModuleOverview
        args: { path: "internal/auth" }
      - tool: getOwnership
        args: { path: "internal/auth" }

  # When touching a high-risk symbol, provide impact preview
  - name: high-risk-symbols
    when:
      symbol_touched:
        - "PaymentProcessor"
        - "AuthHandler"
        - "DatabaseMigration"
    inject:
      - tool: prepareChange
        args: { target: "$SYMBOL_ID" }
      - tool: getAffectedTests
        args: { symbolId: "$SYMBOL_ID" }

  # Before any commit, provide a diff summary
  - name: pre-commit-summary
    when:
      event: pre_commit
    inject:
      - tool: summarizeDiff
        args: { ref: "HEAD" }
```

**Tool:** `getContextTriggers`

```json
// Input
{
  "currentFile": "internal/auth/handler.go",
  "currentSymbol": "HandleLogin",  // optional
  "event": "file_opened"  // "file_opened" | "symbol_focused" | "pre_commit"
}

// Output
{
  "triggeredRules": [
    {
      "name": "auth-context",
      "reason": "File matches **/auth/**",
      "injectedContext": [
        {
          "tool": "getModuleOverview",
          "result": { /* cached result */ }
        },
        {
          "tool": "getOwnership",
          "result": { /* cached result */ }
        }
      ]
    }
  ],
  "cacheHit": true,
  "totalTokensInjected": 850
}
```

**CLI Command:** `ckb triggers check <file>`

**Implementation:**
1. Load triggers from `.ckb/triggers.yaml`
2. Match current context against trigger conditions
3. Execute injected tool calls (with caching)
4. Return aggregated context in single response
5. Track trigger effectiveness (which triggers actually help)

**Value:** Medium-High — reduces exploration overhead by 40-60%.

**Effort:** Medium — config parsing + orchestration.

---

### 4. Enhanced Diff Impact

**Problem:** Current `summarizeDiff` provides textual summary. AI agents need structured, actionable impact data.

**Enhancement to:** `summarizeDiff`

```json
// Current output (text-focused)
{
  "summary": "Changed 5 files, 200 lines added",
  "changes": [...]
}

// Enhanced output (structured + actionable)
{
  "textSummary": "Modified auth flow, added rate limiting",
  "semanticSummary": {
    "categories": [
      { "name": "authentication", "files": 3, "risk": "high" },
      { "name": "rate-limiting", "files": 2, "risk": "medium" }
    ],
    "changeType": "feature"  // "feature" | "bugfix" | "refactor" | "config"
  },
  "symbolsChanged": [
    {
      "symbolId": "ckb:repo:sym:abc123",
      "name": "HandleLogin",
      "changeType": "modified",
      "linesChanged": 15
    }
  ],
  "blastRadius": {
    "directCallers": 12,
    "transitiveImpact": 47,
    "modulesAffected": ["auth", "api", "middleware"],
    "testsAffected": 8
  },
  "ownershipCrossing": {
    "teamsInvolved": ["@backend-team", "@security-team"],
    "primaryOwner": "@backend-team",
    "requiresSecurityReview": true
  },
  "reviewerSuggestions": [
    {
      "user": "alice",
      "reason": "Owns auth module",
      "confidence": 0.95
    },
    {
      "user": "bob",
      "reason": "Touched these files recently",
      "confidence": 0.72
    }
  ],
  "riskFactors": [
    "Crosses module boundaries",
    "Modifies authentication flow",
    "Low test coverage in affected area"
  ],
  "suggestedActions": [
    "Request security team review",
    "Add tests for new rate limiting logic"
  ]
}
```

**Implementation:**
1. Start with existing `summarizeDiff` logic
2. Add symbol extraction from diff hunks
3. Run `prepareChange` for each changed symbol (parallel, cached)
4. Aggregate blast radius across all changes
5. Query ownership for affected modules
6. Generate reviewer suggestions from ownership + git history
7. Calculate compound risk score

**Value:** Medium — improves existing tool without new concepts.

**Effort:** Low-Medium — builds on existing primitives.

---

### 5. Token Budget Advisor

**Problem:** AI agents don't know the most efficient CKB query strategy. They may call 5 tools when 1 would suffice.

**Tool:** `optimizeQuery`

```json
// Input
{
  "intent": "I need to understand the payment flow end-to-end",
  "currentContext": ["file:src/api/routes.go"]  // optional: what agent already knows
}

// Output
{
  "recommendedApproach": [
    {
      "step": 1,
      "tool": "explore",
      "args": { "target": "internal/payments", "depth": "standard" },
      "estimatedTokens": 800,
      "rationale": "Get module overview and key symbols"
    },
    {
      "step": 2,
      "tool": "traceUsage",
      "args": { "symbolId": "ckb:repo:sym:PaymentHandler" },
      "estimatedTokens": 400,
      "rationale": "Trace entry points to payment handling"
    }
  ],
  "avoidThis": [
    {
      "approach": "Grep for 'payment'",
      "reason": "Matches 200+ files, most irrelevant",
      "tokenCost": "~5000+"
    },
    {
      "approach": "Sequential getSymbol calls",
      "reason": "Use batchGet instead for 50%+ savings",
      "tokenCost": "Variable"
    }
  ],
  "totalEstimate": {
    "tokens": 1200,
    "toolCalls": 2,
    "comparedToNaive": "~75% savings"
  }
}
```

**Implementation:**
1. Parse intent into query type (exploration, symbol lookup, impact analysis)
2. Check cached knowledge about the codebase (module structure, symbol counts)
3. Recommend compound tools over granular when applicable
4. Estimate token costs based on cached response sizes
5. Provide anti-patterns specific to the query type

**Heuristics:**
| Intent Pattern | Recommended Tool |
|---------------|------------------|
| "understand X" | `understand` (compound) |
| "what calls X" | `getCallGraph` or `traceUsage` |
| "impact of changing X" | `prepareChange` (compound) |
| "explore area Y" | `explore` (compound) |
| "find symbol by name" | `searchSymbols` + `batchGet` |
| "multiple symbols" | `batchSearch` + `batchGet` |

**Value:** Medium — meta-optimization, helps agents help themselves.

**Effort:** Low — heuristic mapping + cached stats.

---

## Implementation Order

```
v8.2
├── 1. Enhanced summarizeDiff (Low effort, immediate value)
│   └── Extend existing tool with structured output
├── 2. parseBuildErrors (Medium effort, high value)
│   ├── Language-specific error parsing
│   ├── Symbol resolution from file:line
│   └── Candidate suggestion for undefined symbols
├── 3. diagnoseFailure (Medium effort, high value)
│   ├── Error → symbol mapping
│   ├── Recent change correlation
│   └── Fix suggestion generation
├── 4. Context triggers (Medium effort, medium-high value)
│   ├── Trigger config parsing
│   ├── Condition matching engine
│   └── Context aggregation + caching
└── 5. optimizeQuery (Low effort, medium value)
    ├── Intent parsing heuristics
    └── Token estimation from cache stats
```

---

## Success Metrics

| Metric | Target |
|--------|--------|
| Build error → fix time | 50% reduction in tool calls |
| Failure diagnosis accuracy | 80%+ correct root cause identification |
| Context trigger hit rate | 60%+ of triggered context actually used |
| Token efficiency improvement | 30%+ reduction in exploration tokens |

---

## Out of Scope (Separate Products)

### Session Memory / Insights Persistence

**What:** Persist learnings across sessions ("PaymentService requires FeatureFlagService init first").

**Why separate:** This is a cross-cutting concern that spans multiple tools, not just CKB. Requires:
- Session state management
- Insight extraction from conversation
- Knowledge graph for relationships
- Integration with multiple AI clients

**Relationship to CKB:** Will *use* CKB as a data source but lives as a separate product.

### Testing Intelligence (v8.1)

**What:** Full test result parsing, failure correlation, test recommendation engine.

**Why v8.1:** Larger scope, deserves dedicated version. Includes:
- `parseTestResults` — structured test output parsing
- `correlateTestFailure` — map failure to recent changes
- `recommendTests` — smart test selection beyond `getAffectedTests`
- Test coverage tracking and gap analysis

---

## Related Documents

- `docs/ideas.md` — Feature ideas with value/effort matrix
- `docs/plans/roadmap-v8.md` — v8.0 implementation details
- `docs/streaming-design.md` — SSE streaming architecture
- `docs/featureplans/change-impact-analysis.md` — Impact analysis foundation

---

## Appendix: Research Sources

Analysis based on:
- [Claude Code Best Practices](https://www.anthropic.com/engineering/claude-code-best-practices) — Anthropic
- [Context Optimization for AI Coding Agents](https://towardsdatascience.com/how-to-optimize-your-ai-coding-agent-context/) — Towards Data Science
- [Why AI Coding Agents Aren't Production-Ready](https://venturebeat.com/ai/why-ai-coding-agents-arent-production-ready-brittle-context-windows-broken) — VentureBeat
- [Top MCP Servers 2025/2026](https://www.datacamp.com/blog/top-mcp-servers-and-clients) — DataCamp
- [claude-context](https://github.com/zilliztech/claude-context) — Semantic code search MCP
- [code-index-mcp](https://github.com/johnhuang316/code-index-mcp) — AST-based code indexing
