name: Security Audit

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop, 'feature/**']
  schedule:
    # Run weekly on Monday at 6:00 UTC
    - cron: '0 6 * * 1'
  workflow_dispatch:
    inputs:
      scan_history:
        description: 'Scan git history (slower but more thorough)'
        required: false
        default: 'false'
        type: boolean
      min_severity:
        description: 'Minimum severity to report'
        required: false
        default: 'high'
        type: choice
        options:
          - critical
          - high
          - medium
          - low

# ============================================================================
# Security Scan Configuration (opt-out: set to false to disable)
# ============================================================================
env:
  # Secret Detection
  SCAN_CKB_SECRETS: 'true'      # CKB builtin secret scanner
  SCAN_GITLEAKS: 'true'         # Gitleaks secret detection
  SCAN_TRUFFLEHOG: 'true'       # TruffleHog verified secrets

  # SAST (Static Application Security Testing)
  SCAN_GOSEC: 'true'            # Go security checker
  SCAN_SEMGREP: 'true'          # Multi-language SAST

  # Dependency & Vulnerability Scanning
  SCAN_GOVULNCHECK: 'true'      # Go vulnerability database
  SCAN_TRIVY: 'true'            # Trivy vuln + license + SBOM
  SCAN_OSV: 'true'              # Google OSV database

  # Minimum severity for reporting (critical, high, medium, low)
  MIN_SEVERITY: 'high'

concurrency:
  group: security-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  security-events: write
  pull-requests: write

jobs:
  # ============================================================================
  # Secret Detection
  # ============================================================================
  secret-scan:
    name: Secret Detection
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: ${{ github.event.inputs.scan_history == 'true' && 0 || 1 }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Build CKB
        run: go build -o ckb ./cmd/ckb

      - name: Initialize CKB
        run: ./ckb init

      - name: CKB Secret Scan
        id: ckb_secrets
        if: env.SCAN_CKB_SECRETS == 'true'
        run: |
          MIN_SEV="${{ github.event.inputs.min_severity || env.MIN_SEVERITY }}"
          echo "::group::CKB Secret Scan (min severity: $MIN_SEV)"

          ./ckb scan-secrets --min-severity="$MIN_SEV" \
            --exclude="internal/secrets/patterns.go" \
            --exclude="*_test.go" \
            --exclude="testdata/*" \
            --output=json > ckb-secrets.json 2>&1 || true

          FINDINGS=$(jq -r '.summary.totalFindings // 0' ckb-secrets.json 2>/dev/null || echo "0")
          echo "findings=$FINDINGS" >> $GITHUB_OUTPUT
          echo "::endgroup::"

          if [ "$FINDINGS" -gt 0 ]; then
            echo "::warning::CKB found $FINDINGS potential secrets"
          fi

      - name: CKB SARIF Report
        if: env.SCAN_CKB_SECRETS == 'true'
        run: |
          MIN_SEV="${{ github.event.inputs.min_severity || env.MIN_SEVERITY }}"
          ./ckb scan-secrets --min-severity="$MIN_SEV" \
            --exclude="internal/secrets/patterns.go" \
            --exclude="*_test.go" \
            --exclude="testdata/*" \
            --output=sarif > ckb-secrets.sarif 2>&1 || true

      - name: Upload CKB SARIF
        if: env.SCAN_CKB_SECRETS == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ckb-secrets.sarif
          category: ckb-secrets
        continue-on-error: true

      - name: Upload secret scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: secret-scan-results
          path: |
            ckb-secrets.json
            ckb-secrets.sarif
          retention-days: 30
          if-no-files-found: ignore

  # ============================================================================
  # External Secret Scanners (Gitleaks + TruffleHog)
  # ============================================================================
  external-secrets:
    name: External Secret Scanners
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Gitleaks
        if: env.SCAN_GITLEAKS == 'true'
        run: |
          curl -sSfL https://github.com/gitleaks/gitleaks/releases/download/v8.18.4/gitleaks_8.18.4_linux_x64.tar.gz | tar xz
          chmod +x gitleaks
          sudo mv gitleaks /usr/local/bin/

      - name: Gitleaks Scan
        id: gitleaks
        if: env.SCAN_GITLEAKS == 'true'
        run: |
          echo "::group::Gitleaks Scan"
          gitleaks detect --source . --report-format json --report-path gitleaks.json --exit-code 0 || true
          gitleaks detect --source . --report-format sarif --report-path gitleaks.sarif --exit-code 0 || true

          if [ -f gitleaks.json ]; then
            FINDINGS=$(jq 'length' gitleaks.json 2>/dev/null || echo "0")
            echo "findings=$FINDINGS" >> $GITHUB_OUTPUT
          else
            echo "findings=0" >> $GITHUB_OUTPUT
            echo "[]" > gitleaks.json
          fi
          echo "::endgroup::"

      - name: Upload Gitleaks SARIF
        if: env.SCAN_GITLEAKS == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: gitleaks.sarif
          category: gitleaks
        continue-on-error: true

      - name: Install TruffleHog
        if: env.SCAN_TRUFFLEHOG == 'true'
        run: |
          curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin

      - name: TruffleHog Scan
        id: trufflehog
        if: env.SCAN_TRUFFLEHOG == 'true'
        run: |
          echo "::group::TruffleHog Scan"
          trufflehog filesystem . --only-verified --json > trufflehog.json 2>/dev/null || true

          if [ -f trufflehog.json ] && [ -s trufflehog.json ]; then
            FINDINGS=$(wc -l < trufflehog.json | tr -d ' ')
            echo "findings=$FINDINGS" >> $GITHUB_OUTPUT
          else
            echo "findings=0" >> $GITHUB_OUTPUT
            echo "" > trufflehog.json
          fi
          echo "::endgroup::"

      - name: Upload external secret results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: external-secrets-results
          path: |
            gitleaks.json
            gitleaks.sarif
            trufflehog.json
          retention-days: 30
          if-no-files-found: ignore

  # ============================================================================
  # SAST (Static Application Security Testing)
  # ============================================================================
  sast-scan:
    name: SAST Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Install Gosec
        if: env.SCAN_GOSEC == 'true'
        run: go install github.com/securego/gosec/v2/cmd/gosec@latest

      - name: Gosec Scan
        id: gosec
        if: env.SCAN_GOSEC == 'true'
        run: |
          echo "::group::Gosec Security Scan"
          gosec -fmt json -out gosec.json -stdout -verbose=text ./... 2>&1 || true
          gosec -fmt sarif -out gosec.sarif ./... 2>&1 || true

          if [ -f gosec.json ]; then
            FINDINGS=$(jq '.Issues | length' gosec.json 2>/dev/null || echo "0")
            echo "findings=$FINDINGS" >> $GITHUB_OUTPUT
          else
            echo "findings=0" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: Upload Gosec SARIF
        if: env.SCAN_GOSEC == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: gosec.sarif
          category: gosec
        continue-on-error: true

      - name: Semgrep Scan
        id: semgrep
        if: env.SCAN_SEMGREP == 'true'
        run: |
          echo "::group::Semgrep SAST Scan"
          pip install semgrep

          # Run with Go security rules
          semgrep scan --config=p/golang --config=p/security-audit \
            --json --output=semgrep.json \
            --sarif --sarif-output=semgrep.sarif \
            . 2>&1 || true

          if [ -f semgrep.json ]; then
            FINDINGS=$(jq '.results | length' semgrep.json 2>/dev/null || echo "0")
            echo "findings=$FINDINGS" >> $GITHUB_OUTPUT
          else
            echo "findings=0" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: Upload Semgrep SARIF
        if: env.SCAN_SEMGREP == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep.sarif
          category: semgrep
        continue-on-error: true

      - name: Upload SAST results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: sast-results
          path: |
            gosec.json
            gosec.sarif
            semgrep.json
            semgrep.sarif
          retention-days: 30
          if-no-files-found: ignore

  # ============================================================================
  # Dependency & Vulnerability Scanning
  # ============================================================================
  dependency-scan:
    name: Dependency & Vulnerability Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Govulncheck
        id: govulncheck
        if: env.SCAN_GOVULNCHECK == 'true'
        run: |
          echo "::group::Govulncheck"
          go install golang.org/x/vuln/cmd/govulncheck@latest
          govulncheck -format json ./... > govulncheck.json 2>&1 || true

          if [ -f govulncheck.json ]; then
            # Check if vulns array exists and is not null
            if jq -e '.vulns != null and (.vulns | length) > 0' govulncheck.json > /dev/null 2>&1; then
              FINDINGS=$(jq '.vulns | length' govulncheck.json)
              echo "findings=$FINDINGS" >> $GITHUB_OUTPUT
              echo "::warning::Found $FINDINGS vulnerable dependencies"
            else
              echo "findings=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "findings=0" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: Install Trivy
        if: env.SCAN_TRIVY == 'true'
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

      - name: Trivy Vulnerability Scan
        id: trivy_vuln
        if: env.SCAN_TRIVY == 'true'
        run: |
          echo "::group::Trivy Vulnerability Scan"
          trivy fs . --scanners vuln --format json --output trivy-vuln.json 2>&1 || true
          trivy fs . --scanners vuln --format sarif --output trivy-vuln.sarif 2>&1 || true

          if [ -f trivy-vuln.json ]; then
            FINDINGS=$(jq '[.Results[]?.Vulnerabilities // [] | length] | add // 0' trivy-vuln.json 2>/dev/null || echo "0")
            echo "findings=$FINDINGS" >> $GITHUB_OUTPUT
          else
            echo "findings=0" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: Trivy License Scan
        id: trivy_license
        if: env.SCAN_TRIVY == 'true'
        run: |
          echo "::group::Trivy License Scan"
          trivy fs . --scanners license --format json --output trivy-license.json 2>&1 || true

          if [ -f trivy-license.json ]; then
            # Count non-permissive licenses
            FINDINGS=$(jq '[.Results[]?.Licenses // [] | .[] | select(.Category != "permissive")] | length' trivy-license.json 2>/dev/null || echo "0")
            echo "findings=$FINDINGS" >> $GITHUB_OUTPUT
          else
            echo "findings=0" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: Trivy SBOM Generation
        if: env.SCAN_TRIVY == 'true'
        run: |
          echo "::group::Trivy SBOM"
          trivy fs . --format cyclonedx --output sbom.json 2>&1 || true
          echo "::endgroup::"

      - name: Upload Trivy SARIF
        if: env.SCAN_TRIVY == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-vuln.sarif
          category: trivy
        continue-on-error: true

      - name: OSV-Scanner
        id: osv
        if: env.SCAN_OSV == 'true'
        run: |
          echo "::group::OSV-Scanner"
          go install github.com/google/osv-scanner/cmd/osv-scanner@latest
          osv-scanner --format json --output osv.json . 2>&1 || true

          if [ -f osv.json ]; then
            FINDINGS=$(jq '.results | map(.packages | length) | add // 0' osv.json 2>/dev/null || echo "0")
            echo "findings=$FINDINGS" >> $GITHUB_OUTPUT
          else
            echo "findings=0" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: Upload dependency scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: dependency-scan-results
          path: |
            govulncheck.json
            trivy-vuln.json
            trivy-vuln.sarif
            trivy-license.json
            sbom.json
            osv.json
          retention-days: 30
          if-no-files-found: ignore

  # ============================================================================
  # Security Gate - Consolidated Results & PR Comment
  # ============================================================================
  security-gate:
    name: Security Gate
    runs-on: ubuntu-latest
    needs: [secret-scan, external-secrets, sast-scan, dependency-scan]
    if: always()
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: results
        continue-on-error: true

      - name: Check results
        id: check
        run: |
          echo "### Security Audit Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Secret Scan | ${{ needs.secret-scan.result == 'success' && '‚úÖ' || '‚ö†Ô∏è' }} ${{ needs.secret-scan.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| External Secrets | ${{ needs.external-secrets.result == 'success' && '‚úÖ' || '‚ö†Ô∏è' }} ${{ needs.external-secrets.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| SAST Analysis | ${{ needs.sast-scan.result == 'success' && '‚úÖ' || '‚ö†Ô∏è' }} ${{ needs.sast-scan.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Dependency Scan | ${{ needs.dependency-scan.result == 'success' && '‚úÖ' || '‚ö†Ô∏è' }} ${{ needs.dependency-scan.result }} |" >> $GITHUB_STEP_SUMMARY

          # Check for critical failures
          if [ "${{ needs.secret-scan.result }}" == "failure" ]; then
            echo "failed=true" >> $GITHUB_OUTPUT
          fi

      - name: Consolidated PR Comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Helper to safely read JSON
            const readJSON = (path) => {
              try {
                return JSON.parse(fs.readFileSync(path, 'utf8'));
              } catch { return null; }
            };

            // Helper to read file content
            const readFile = (path) => {
              try {
                return fs.readFileSync(path, 'utf8').trim();
              } catch { return ''; }
            };

            // Build consolidated comment
            let body = `## üîê Security Audit Results\n\n`;

            // Overall status
            const jobs = {
              secrets: '${{ needs.secret-scan.result }}',
              external: '${{ needs.external-secrets.result }}',
              sast: '${{ needs.sast-scan.result }}',
              deps: '${{ needs.dependency-scan.result }}'
            };

            const allPassed = Object.values(jobs).every(r => r === 'success');
            body += allPassed
              ? `‚úÖ **All security checks passed**\n\n`
              : `‚ö†Ô∏è **Some security checks need attention**\n\n`;

            // Summary table
            body += `| Category | Status |\n|----------|--------|\n`;
            body += `| üîë Secret Detection | ${jobs.secrets === 'success' ? '‚úÖ' : '‚ö†Ô∏è'} ${jobs.secrets} |\n`;
            body += `| üîç External Scanners | ${jobs.external === 'success' ? '‚úÖ' : '‚ö†Ô∏è'} ${jobs.external} |\n`;
            body += `| üõ°Ô∏è SAST Analysis | ${jobs.sast === 'success' ? '‚úÖ' : '‚ö†Ô∏è'} ${jobs.sast} |\n`;
            body += `| üì¶ Dependencies | ${jobs.deps === 'success' ? '‚úÖ' : '‚ö†Ô∏è'} ${jobs.deps} |\n\n`;

            // ==================== SECRET DETECTION ====================
            let secretFindings = [];

            // CKB Secrets
            const ckbSecrets = readJSON('results/secret-scan-results/ckb-secrets.json');
            if (ckbSecrets?.summary?.totalFindings > 0) {
              secretFindings.push({
                tool: 'CKB',
                count: ckbSecrets.summary.totalFindings,
                items: ckbSecrets.findings?.slice(0, 5).map(f =>
                  `\`${f.file}:${f.line}\` - ${f.type} (${f.severity})`
                ) || []
              });
            }

            // Gitleaks
            const gitleaks = readJSON('results/external-secrets-results/gitleaks.json');
            if (Array.isArray(gitleaks) && gitleaks.length > 0) {
              secretFindings.push({
                tool: 'Gitleaks',
                count: gitleaks.length,
                items: gitleaks.slice(0, 5).map(f =>
                  `\`${f.File}:${f.StartLine}\` - ${f.RuleID || 'secret'}`
                )
              });
            }

            // TruffleHog
            const thContent = readFile('results/external-secrets-results/trufflehog.json');
            if (thContent) {
              const thFindings = thContent.split('\n').filter(l => l.trim()).map(l => {
                try { return JSON.parse(l); } catch { return null; }
              }).filter(Boolean);
              if (thFindings.length > 0) {
                secretFindings.push({
                  tool: 'TruffleHog',
                  count: thFindings.length,
                  verified: true,
                  items: thFindings.slice(0, 5).map(f => {
                    const file = f.SourceMetadata?.Data?.Filesystem?.file || 'unknown';
                    return `\`${file}\` - ${f.DetectorName} ${f.Verified ? '‚úÖ' : ''}`;
                  })
                });
              }
            }

            if (secretFindings.length > 0) {
              const totalSecrets = secretFindings.reduce((sum, s) => sum + s.count, 0);
              body += `### üîë Secret Detection\n\n`;
              body += `Found **${totalSecrets}** potential secret(s) across ${secretFindings.length} scanner(s)\n\n`;
              body += `<details><summary>Details</summary>\n\n`;
              for (const s of secretFindings) {
                body += `**${s.tool}** (${s.count} finding${s.count > 1 ? 's' : ''})${s.verified ? ' - verified' : ''}\n`;
                for (const item of s.items) {
                  body += `- ${item}\n`;
                }
                if (s.count > 5) body += `- ... and ${s.count - 5} more\n`;
                body += '\n';
              }
              body += `</details>\n\n`;
            }

            // ==================== SAST FINDINGS ====================
            let sastFindings = [];

            // Gosec
            const gosec = readJSON('results/sast-results/gosec.json');
            if (gosec?.Issues?.length > 0) {
              sastFindings.push({
                tool: 'Gosec',
                count: gosec.Issues.length,
                items: gosec.Issues.slice(0, 5).map(i =>
                  `\`${i.file}:${i.line}\` - ${i.rule_id}: ${i.details?.substring(0, 60) || 'N/A'}...`
                )
              });
            }

            // Semgrep
            const semgrep = readJSON('results/sast-results/semgrep.json');
            if (semgrep?.results?.length > 0) {
              sastFindings.push({
                tool: 'Semgrep',
                count: semgrep.results.length,
                items: semgrep.results.slice(0, 5).map(r =>
                  `\`${r.path}:${r.start?.line}\` - ${r.check_id}`
                )
              });
            }

            if (sastFindings.length > 0) {
              const totalSast = sastFindings.reduce((sum, s) => sum + s.count, 0);
              body += `### üõ°Ô∏è SAST Analysis\n\n`;
              body += `Found **${totalSast}** issue(s) across ${sastFindings.length} scanner(s)\n\n`;
              body += `<details><summary>Details</summary>\n\n`;
              for (const s of sastFindings) {
                body += `**${s.tool}** (${s.count} finding${s.count > 1 ? 's' : ''})\n`;
                for (const item of s.items) {
                  body += `- ${item}\n`;
                }
                if (s.count > 5) body += `- ... and ${s.count - 5} more\n`;
                body += '\n';
              }
              body += `</details>\n\n`;
            }

            // ==================== DEPENDENCY VULNERABILITIES ====================
            let depFindings = [];

            // Govulncheck
            const govuln = readJSON('results/dependency-scan-results/govulncheck.json');
            if (govuln?.vulns?.length > 0) {
              depFindings.push({
                tool: 'govulncheck',
                count: govuln.vulns.length,
                items: govuln.vulns.slice(0, 5).map(v =>
                  `**${v.osv?.id || 'Unknown'}**: ${v.osv?.summary?.substring(0, 80) || 'No summary'}...`
                )
              });
            }

            // Trivy Vulnerabilities
            const trivyVuln = readJSON('results/dependency-scan-results/trivy-vuln.json');
            if (trivyVuln?.Results) {
              const vulns = trivyVuln.Results.flatMap(r => r.Vulnerabilities || []);
              if (vulns.length > 0) {
                depFindings.push({
                  tool: 'Trivy',
                  count: vulns.length,
                  items: vulns.slice(0, 5).map(v =>
                    `**${v.VulnerabilityID}** (${v.Severity}): ${v.PkgName} - ${v.Title?.substring(0, 50) || 'N/A'}...`
                  )
                });
              }
            }

            // OSV-Scanner
            const osv = readJSON('results/dependency-scan-results/osv.json');
            if (osv?.results) {
              const osvVulns = osv.results.flatMap(r => r.packages || []);
              if (osvVulns.length > 0) {
                depFindings.push({
                  tool: 'OSV-Scanner',
                  count: osvVulns.length,
                  items: osvVulns.slice(0, 5).map(p =>
                    `**${p.package?.name || 'unknown'}**: ${p.vulnerabilities?.length || 0} vulnerabilities`
                  )
                });
              }
            }

            if (depFindings.length > 0) {
              const totalDeps = depFindings.reduce((sum, s) => sum + s.count, 0);
              body += `### üì¶ Dependency Vulnerabilities\n\n`;
              body += `Found **${totalDeps}** issue(s) across ${depFindings.length} scanner(s)\n\n`;
              body += `<details><summary>Details</summary>\n\n`;
              for (const s of depFindings) {
                body += `**${s.tool}** (${s.count} finding${s.count > 1 ? 's' : ''})\n`;
                for (const item of s.items) {
                  body += `- ${item}\n`;
                }
                if (s.count > 5) body += `- ... and ${s.count - 5} more\n`;
                body += '\n';
              }
              body += `</details>\n\n`;
            }

            // ==================== LICENSE COMPLIANCE ====================
            const trivyLicense = readJSON('results/dependency-scan-results/trivy-license.json');
            if (trivyLicense?.Results) {
              const licenses = trivyLicense.Results.flatMap(r => r.Licenses || []);
              const nonPermissive = licenses.filter(l => l.Category !== 'permissive');
              if (nonPermissive.length > 0) {
                body += `### üìú License Compliance\n\n`;
                body += `Found **${nonPermissive.length}** non-permissive license(s)\n\n`;
                body += `<details><summary>Details</summary>\n\n`;
                for (const l of nonPermissive.slice(0, 10)) {
                  body += `- **${l.Name}** (${l.Category}): ${l.PkgName || 'N/A'}\n`;
                }
                if (nonPermissive.length > 10) {
                  body += `\n... and ${nonPermissive.length - 10} more\n`;
                }
                body += `</details>\n\n`;
              }
            }

            // ==================== FOOTER ====================
            body += `---\n`;
            body += `<sub>ü§ñ Generated by CKB Security Audit | `;
            body += `[View Details](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) | `;
            body += `[Security Tab](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/security/code-scanning)</sub>`;

            // ==================== POST/UPDATE COMMENT ====================
            // Find existing security audit comment to update (avoids spam on multiple pushes)
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            // Look for our previous comment by checking for Bot user and our unique header
            const botComment = comments.find(c =>
              c.user?.type === 'Bot' &&
              c.body?.includes('üîê Security Audit Results')
            );

            if (botComment) {
              // Update existing comment instead of creating a new one
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment if this is the first run
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Fail if critical issues
        if: steps.check.outputs.failed == 'true'
        run: exit 1
