name: Security Audit

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop, 'feature/**']
  schedule:
    # Run weekly on Monday at 6:00 UTC
    - cron: '0 6 * * 1'
  workflow_dispatch:
    inputs:
      scan_history:
        description: 'Scan git history (slower but more thorough)'
        required: false
        default: 'false'
        type: boolean
      min_severity:
        description: 'Minimum severity to report'
        required: false
        default: 'high'
        type: choice
        options:
          - critical
          - high
          - medium
          - low

concurrency:
  group: security-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  security-events: write
  pull-requests: write

jobs:
  secret-scan:
    name: Secret Detection
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: ${{ github.event.inputs.scan_history == 'true' && 0 || 1 }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Build CKB
        run: go build -o ckb ./cmd/ckb

      - name: Initialize CKB
        run: ./ckb init

      - name: Scan for secrets (working directory)
        id: scan_workdir
        run: |
          # Determine minimum severity
          MIN_SEVERITY="${{ github.event.inputs.min_severity || 'high' }}"

          echo "::group::Running secret scan (min severity: $MIN_SEVERITY)"

          # Run scan and capture output
          # Exclude patterns.go (contains pattern definitions, not real secrets)
          # Exclude test files (contain test fixtures)
          ./ckb scan-secrets --min-severity="$MIN_SEVERITY" \
            --exclude="internal/secrets/patterns.go" \
            --exclude="*_test.go" \
            --exclude="testdata/*" \
            --output=json > secrets-report.json 2>&1 || true

          # Check if any findings
          FINDINGS=$(jq -r '.summary.totalFindings // 0' secrets-report.json 2>/dev/null || echo "0")
          echo "findings=$FINDINGS" >> $GITHUB_OUTPUT

          echo "::endgroup::"

          # Display summary
          if [ "$FINDINGS" -gt 0 ]; then
            echo "::warning::Found $FINDINGS potential secrets in the codebase"
            echo ""
            echo "### Secret Scan Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Severity | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            jq -r '.summary.bySeverity | to_entries[] | "| \(.key) | \(.value) |"' secrets-report.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Files affected:** $(jq -r '.summary.filesWithSecrets // 0' secrets-report.json)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details><summary>Details</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```json' >> $GITHUB_STEP_SUMMARY
            jq '.findings[] | {file, line, type, severity, match, rule}' secrets-report.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          else
            echo "### Secret Scan Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ No secrets detected" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Scan git history (if enabled)
        if: github.event.inputs.scan_history == 'true'
        id: scan_history
        run: |
          echo "::group::Scanning git history"

          ./ckb scan-secrets --scope=history --max-commits=100 --min-severity=high --output=json > secrets-history.json 2>&1 || true

          HISTORY_FINDINGS=$(jq -r '.summary.totalFindings // 0' secrets-history.json 2>/dev/null || echo "0")
          echo "history_findings=$HISTORY_FINDINGS" >> $GITHUB_OUTPUT

          echo "::endgroup::"

          if [ "$HISTORY_FINDINGS" -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Git History Scan" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è Found **$HISTORY_FINDINGS** secrets in git history" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Consider rotating these credentials and using [git-filter-repo](https://github.com/newren/git-filter-repo) to remove them from history." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Generate SARIF report
        if: always()
        run: |
          MIN_SEVERITY="${{ github.event.inputs.min_severity || 'high' }}"
          ./ckb scan-secrets --min-severity="$MIN_SEVERITY" \
            --exclude="internal/secrets/patterns.go" \
            --exclude="*_test.go" \
            --exclude="testdata/*" \
            --output=sarif > secrets-report.sarif 2>&1 || true

      - name: Upload SARIF to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: secrets-report.sarif
          category: ckb-secrets

      - name: Upload scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: secret-scan-results
          path: |
            secrets-report.json
            secrets-report.sarif
            secrets-history.json
          retention-days: 30
          if-no-files-found: ignore

      - name: Fail on critical findings
        if: always()
        run: |
          CRITICAL=$(jq -r '.summary.bySeverity.critical // 0' secrets-report.json 2>/dev/null || echo "0")
          if [ "$CRITICAL" -gt 0 ]; then
            echo "::error::Found $CRITICAL critical severity secrets. Please remove them before merging."
            exit 1
          fi

  # Optional: Run external tools for comprehensive coverage
  external-scan:
    name: External Secret Scanners
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Gitleaks
        run: |
          curl -sSfL https://github.com/gitleaks/gitleaks/releases/download/v8.18.4/gitleaks_8.18.4_linux_x64.tar.gz | tar xz
          chmod +x gitleaks
          sudo mv gitleaks /usr/local/bin/

      - name: Run Gitleaks
        id: gitleaks
        run: |
          # Run gitleaks and capture JSON output
          gitleaks detect --source . --report-format json --report-path gitleaks-report.json --exit-code 0 || true

          # Count findings
          if [ -f gitleaks-report.json ]; then
            FINDINGS=$(jq 'length' gitleaks-report.json 2>/dev/null || echo "0")
            echo "findings=$FINDINGS" >> $GITHUB_OUTPUT
          else
            echo "findings=0" >> $GITHUB_OUTPUT
            echo "[]" > gitleaks-report.json
          fi
        continue-on-error: true

      - name: Run TruffleHog
        id: trufflehog
        run: |
          # Install trufflehog
          curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin

          # Run trufflehog and capture JSON output
          trufflehog filesystem . --only-verified --json > trufflehog-report.json 2>/dev/null || true

          # Count findings
          if [ -f trufflehog-report.json ] && [ -s trufflehog-report.json ]; then
            FINDINGS=$(wc -l < trufflehog-report.json | tr -d ' ')
            echo "findings=$FINDINGS" >> $GITHUB_OUTPUT
          else
            echo "findings=0" >> $GITHUB_OUTPUT
            echo "" > trufflehog-report.json
          fi
        continue-on-error: true

      - name: Upload external scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: external-scan-results
          path: |
            gitleaks-report.json
            trufflehog-report.json
          retention-days: 7

  dependency-audit:
    name: Dependency Vulnerabilities
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Run govulncheck
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          govulncheck -format json ./... > vuln-report.json 2>&1 || true

          # Check for vulnerabilities
          if grep -q '"vulns":' vuln-report.json && ! grep -q '"vulns": null' vuln-report.json; then
            echo "::warning::Dependency vulnerabilities found"
            govulncheck ./...
          else
            echo "‚úÖ No known vulnerabilities in dependencies"
          fi

      - name: Upload vulnerability report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: vulnerability-report
          path: vuln-report.json
          retention-days: 30

  # Summary job that requires all checks to pass
  security-gate:
    name: Security Gate
    runs-on: ubuntu-latest
    needs: [secret-scan, external-scan, dependency-audit]
    if: always()
    steps:
      - name: Download secret scan results
        uses: actions/download-artifact@v4
        with:
          name: secret-scan-results
          path: results/secrets
        continue-on-error: true

      - name: Download vulnerability report
        uses: actions/download-artifact@v4
        with:
          name: vulnerability-report
          path: results/vuln
        continue-on-error: true

      - name: Download external scan results
        uses: actions/download-artifact@v4
        with:
          name: external-scan-results
          path: results/external
        continue-on-error: true

      - name: Check results
        id: check
        run: |
          if [ "${{ needs.secret-scan.result }}" == "failure" ]; then
            echo "::error::Secret scan failed - critical secrets detected"
            echo "failed=true" >> $GITHUB_OUTPUT
          fi

          echo "‚úÖ Security audit passed"
          echo ""
          echo "### Security Audit Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Secret Scan (CKB) | ${{ needs.secret-scan.result == 'success' && '‚úÖ Passed' || '‚ö†Ô∏è ' }}${{ needs.secret-scan.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| External Scanners | ${{ needs.external-scan.result == 'success' && '‚úÖ Passed' || '‚ö†Ô∏è ' }}${{ needs.external-scan.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Dependency Audit | ${{ needs.dependency-audit.result == 'success' && '‚úÖ Passed' || '‚ö†Ô∏è ' }}${{ needs.dependency-audit.result }} |" >> $GITHUB_STEP_SUMMARY

      - name: Consolidated PR Comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Build consolidated comment
            let body = `## üîê Security Audit Results\n\n`;

            // Overall status
            const secretResult = '${{ needs.secret-scan.result }}';
            const externalResult = '${{ needs.external-scan.result }}';
            const vulnResult = '${{ needs.dependency-audit.result }}';

            const allPassed = secretResult === 'success' && vulnResult === 'success';
            body += allPassed
              ? `‚úÖ **All security checks passed**\n\n`
              : `‚ö†Ô∏è **Some security checks need attention**\n\n`;

            // Summary table
            body += `| Check | Status |\n|-------|--------|\n`;
            body += `| Secret Scan (CKB) | ${secretResult === 'success' ? '‚úÖ' : '‚ö†Ô∏è'} ${secretResult} |\n`;
            body += `| External Scanners | ${externalResult === 'success' ? '‚úÖ' : '‚ö†Ô∏è'} ${externalResult} |\n`;
            body += `| Dependency Audit | ${vulnResult === 'success' ? '‚úÖ' : '‚ö†Ô∏è'} ${vulnResult} |\n\n`;

            // Secret scan details (CKB)
            try {
              const secretReport = JSON.parse(fs.readFileSync('results/secrets/secrets-report.json', 'utf8'));
              if (secretReport.summary?.totalFindings > 0) {
                body += `### üîë CKB Secret Detection\n\n`;
                body += `Found **${secretReport.summary.totalFindings}** potential secret(s)\n\n`;

                if (secretReport.summary.bySeverity) {
                  body += `| Severity | Count |\n|----------|-------|\n`;
                  for (const [sev, count] of Object.entries(secretReport.summary.bySeverity)) {
                    const icon = sev === 'critical' ? 'üî¥' : sev === 'high' ? 'üü†' : sev === 'medium' ? 'üü°' : '‚ö™';
                    body += `| ${icon} ${sev} | ${count} |\n`;
                  }
                  body += '\n';
                }

                // Group by file
                body += `<details><summary>Files with potential secrets</summary>\n\n`;
                const fileGroups = {};
                for (const f of secretReport.findings || []) {
                  if (!fileGroups[f.file]) fileGroups[f.file] = [];
                  fileGroups[f.file].push(f);
                }
                for (const [file, findings] of Object.entries(fileGroups).slice(0, 10)) {
                  body += `- \`${file}\`\n`;
                  for (const f of findings.slice(0, 3)) {
                    body += `  - Line ${f.line}: ${f.type} (${f.severity})\n`;
                  }
                  if (findings.length > 3) {
                    body += `  - ... and ${findings.length - 3} more\n`;
                  }
                }
                if (Object.keys(fileGroups).length > 10) {
                  body += `\n... and ${Object.keys(fileGroups).length - 10} more files\n`;
                }
                body += `</details>\n\n`;
              }
            } catch (e) {
              // No secret report or empty
            }

            // Gitleaks findings
            try {
              const gitleaksReport = JSON.parse(fs.readFileSync('results/external/gitleaks-report.json', 'utf8'));
              if (Array.isArray(gitleaksReport) && gitleaksReport.length > 0) {
                body += `### üîç Gitleaks Findings\n\n`;
                body += `Found **${gitleaksReport.length}** secret(s)\n\n`;

                body += `<details><summary>Details</summary>\n\n`;
                const byFile = {};
                for (const f of gitleaksReport) {
                  const file = f.File || 'unknown';
                  if (!byFile[file]) byFile[file] = [];
                  byFile[file].push(f);
                }
                for (const [file, findings] of Object.entries(byFile).slice(0, 10)) {
                  body += `- \`${file}\`\n`;
                  for (const f of findings.slice(0, 3)) {
                    body += `  - Line ${f.StartLine || '?'}: \`${f.RuleID || f.Rule || 'unknown'}\`\n`;
                  }
                  if (findings.length > 3) {
                    body += `  - ... and ${findings.length - 3} more\n`;
                  }
                }
                if (Object.keys(byFile).length > 10) {
                  body += `\n... and ${Object.keys(byFile).length - 10} more files\n`;
                }
                body += `</details>\n\n`;
              }
            } catch (e) {
              // No gitleaks report or empty
            }

            // TruffleHog findings (verified secrets)
            try {
              const thContent = fs.readFileSync('results/external/trufflehog-report.json', 'utf8').trim();
              if (thContent) {
                // TruffleHog outputs NDJSON (one JSON per line)
                const lines = thContent.split('\n').filter(l => l.trim());
                const thFindings = lines.map(l => { try { return JSON.parse(l); } catch { return null; } }).filter(Boolean);
                if (thFindings.length > 0) {
                  body += `### üê∑ TruffleHog (Verified Secrets)\n\n`;
                  body += `Found **${thFindings.length}** verified secret(s)\n\n`;

                  body += `<details><summary>Details</summary>\n\n`;
                  for (const f of thFindings.slice(0, 10)) {
                    const detector = f.DetectorName || 'Unknown';
                    const file = f.SourceMetadata?.Data?.Filesystem?.file || 'unknown';
                    const line = f.SourceMetadata?.Data?.Filesystem?.line || '?';
                    body += `- \`${file}:${line}\` - ${detector} ${f.Verified ? '‚úÖ verified' : ''}\n`;
                  }
                  if (thFindings.length > 10) {
                    body += `\n... and ${thFindings.length - 10} more\n`;
                  }
                  body += `</details>\n\n`;
                }
              }
            } catch (e) {
              // No trufflehog report or empty
            }

            // Vulnerability details
            try {
              const vulnReport = JSON.parse(fs.readFileSync('results/vuln/vuln-report.json', 'utf8'));
              if (vulnReport.vulns && vulnReport.vulns.length > 0) {
                body += `### üì¶ Dependency Vulnerabilities\n\n`;
                body += `Found **${vulnReport.vulns.length}** vulnerable dependencies\n\n`;
                body += `<details><summary>Details</summary>\n\n`;
                for (const v of vulnReport.vulns.slice(0, 5)) {
                  body += `- **${v.osv?.id || 'Unknown'}**: ${v.osv?.summary || 'No summary'}\n`;
                }
                if (vulnReport.vulns.length > 5) {
                  body += `\n... and ${vulnReport.vulns.length - 5} more\n`;
                }
                body += `</details>\n\n`;
              }
            } catch (e) {
              // No vuln report or parsing error
            }

            body += `---\n`;
            body += `<sub>ü§ñ Generated by CKB Security Audit | [View Details](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})</sub>`;

            // Find existing comment to update (avoid spam)
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.find(c =>
              c.user?.type === 'Bot' &&
              c.body?.includes('üîê Security Audit Results')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Fail if critical issues
        if: steps.check.outputs.failed == 'true'
        run: exit 1
