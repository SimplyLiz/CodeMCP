name: NFR Tests

on:
  pull_request:
    branches: [develop, main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  nfr:
    name: NFR Scenarios
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Run NFR Tests
        id: nfr
        run: |
          # Run NFR tests
          set +e
          go test -v -run TestNFRScenarios ./internal/mcp/... 2>&1 | tee nfr-output.txt
          TEST_EXIT=${PIPESTATUS[0]}
          set -e

          # Parse results - count all PASS/FAIL lines including subtests
          PASS=$(grep -c -- "--- PASS" nfr-output.txt) || PASS=0
          FAIL=$(grep -c -- "--- FAIL" nfr-output.txt) || FAIL=0
          TOTAL=$((PASS + FAIL))

          # Job summary
          echo "## ðŸ“Š NFR Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| âœ… Passed | $PASS |" >> $GITHUB_STEP_SUMMARY
          echo "| âŒ Failed | $FAIL |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ“Š Total | $TOTAL |" >> $GITHUB_STEP_SUMMARY

          # Set outputs for PR comment
          echo "pass=$PASS" >> $GITHUB_OUTPUT
          echo "fail=$FAIL" >> $GITHUB_OUTPUT
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "exit_code=$TEST_EXIT" >> $GITHUB_OUTPUT

          exit $TEST_EXIT

      - name: Parse NFR metrics
        id: metrics
        if: always()
        run: |
          # Extract actual token counts and timings from test output
          # Format: tool_tier_actual_baseline_status

          cat > parse_nfr.py << 'EOF'
          import re

          def fmt_time(t):
              """Normalize timing: Âµs if <1ms, else ms"""
              t = t.strip()
              if "ms" in t and "Âµs" not in t:
                  return t  # already ms
              if "Âµs" in t:
                  val = float(t.replace("Âµs", ""))
                  if val >= 1000:
                      return f"{val/1000:.2f}ms"
                  return f"{val:.0f}Âµs"
              return t

          rows = []

          with open("nfr-output.txt", "r") as f:
              content = f.read()

          # Parse: "searchSymbols_small: 3500 bytes (baseline: 3600, max: 3960) [1.234ms]"
          pattern = r'(\w+)_(\w+): (\d+) bytes \(baseline: (\d+), max: (\d+)\) \[([^\]]+)\]'
          for match in re.finditer(pattern, content):
              tool, tier, actual, baseline, max_allowed, timing = match.groups()
              actual, baseline, max_allowed = int(actual), int(baseline), int(max_allowed)
              diff_pct = ((actual - baseline) / baseline) * 100
              budget_pct = (actual / max_allowed) * 100 if max_allowed > 0 else 0

              if diff_pct >= 10:
                  verdict = "FAIL"
              elif diff_pct >= 5:
                  verdict = "WARN"
              elif diff_pct <= -5:
                  verdict = "GOOD"
              else:
                  verdict = "OK"

              rows.append({
                  "tool": tool, "tier": tier, "actual": actual,
                  "baseline": baseline, "max": max_allowed,
                  "diff_pct": diff_pct, "budget_pct": budget_pct,
                  "timing": fmt_time(timing), "verdict": verdict
              })

          if rows:
              # Categorize
              fails = [r for r in rows if r["verdict"] == "FAIL"]
              warns = [r for r in rows if r["verdict"] == "WARN"]
              goods = [r for r in rows if r["verdict"] == "GOOD"]
              regressions = fails + warns
              savings = goods

              # Find highlights
              increases = [r for r in rows if r["diff_pct"] > 0]
              worst_reg = max(increases, key=lambda r: r["diff_pct"]) if increases else None
              best_impr = min(rows, key=lambda r: r["diff_pct"])
              hotspots = sorted([r for r in rows if r["budget_pct"] >= 90], key=lambda r: -r["budget_pct"])[:3]
              hotspot_count = sum(1 for r in rows if r["budget_pct"] >= 90)

              total = len(rows)
              oks = [r for r in rows if r["verdict"] == "OK"]

              # Headline with horizontal indicators
              indicators = []
              if fails:
                  indicators.append(f"âŒ {len(fails)} failed")
              if warns:
                  indicators.append(f"âš ï¸ {len(warns)} regressed")
              if goods:
                  indicators.append(f"ðŸ“ˆ {len(goods)} improved")
              indicators.append(f"âœ… {len(oks)} passed")

              status = "âŒ" if fails else "âš ï¸" if warns else "âœ…"
              print(f"## NFR Tests {status} {' Â· '.join(indicators)}\n")

              # Diff block preview (top 3 each)
              preview_bad = sorted([r for r in rows if r["diff_pct"] >= 5], key=lambda r: -r["diff_pct"])[:3]
              preview_good = sorted([r for r in rows if r["diff_pct"] <= -5], key=lambda r: r["diff_pct"])[:3]

              if preview_bad or preview_good:
                  # Calculate max width for alignment
                  all_preview = preview_bad + preview_good
                  max_name = max(len(f"{r['tool']}/{r['tier']}") for r in all_preview)
                  print("```diff")
                  for r in preview_bad:
                      name = f"{r['tool']}/{r['tier']}"
                      print(f"- {r['verdict']:4} {name:<{max_name}}  {r['diff_pct']:+6.1f}%  {r['actual']:>9,}B  budget {r['budget_pct']:>2.0f}%  {r['timing']}")
                  for r in preview_good:
                      name = f"{r['tool']}/{r['tier']}"
                      print(f"+ SAVE {name:<{max_name}}  {r['diff_pct']:+6.1f}%  {r['actual']:>9,}B  budget {r['budget_pct']:>2.0f}%  {r['timing']}")
                  print("```\n")

              # Hotspots table (if any)
              if hotspots:
                  print("### Hotspots (closest to limit)\n")
                  print("| Scenario | Budget | Margin |")
                  print("|---|---:|---:|")
                  for h in hotspots:
                      margin = 100 - h["budget_pct"]
                      print(f"| {h['tool']} / {h['tier']} | {h['budget_pct']:.0f}% | {margin:.0f}% |")
                  print()

              # Full breakdown in details
              print("<details><summary>All scenarios</summary>\n")
              print("| | Scenario | Change | Actual (B) | Baseline | Max | Budget | Margin | Time |")
              print("|:---:|---|---:|---:|---:|---:|---:|---:|---:|")
              for r in sorted(rows, key=lambda x: -x["diff_pct"]):
                  margin = 100 - r["budget_pct"]
                  if r["verdict"] == "FAIL":
                      icon = "ðŸ”´"
                  elif r["verdict"] == "WARN":
                      icon = "ðŸŸ¡"
                  elif r["verdict"] == "GOOD":
                      icon = "ðŸŸ¢"
                  else:
                      icon = "âšª"
                  print(f"| {icon} | {r['tool']} / {r['tier']} | {r['diff_pct']:+.1f}% | {r['actual']:,} | {r['baseline']:,} | {r['max']:,} | {r['budget_pct']:.0f}% | {margin:.0f}% | {r['timing']} |")
              print("\n</details>")
          else:
              print("No token metrics found in output")
          EOF

          if ! python3 parse_nfr.py > nfr-table.md 2>&1; then
            echo "::warning::Failed to parse NFR metrics"
            echo "No metrics parsed" > nfr-table.md
          fi
          cat nfr-table.md

      - name: Comment on PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let body = 'No NFR metrics available';
            try {
              body = fs.readFileSync('nfr-table.md', 'utf8');
            } catch (e) {}

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('NFR Budget')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Upload NFR results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: nfr-results
          path: |
            nfr-output.txt
            nfr-table.md
          retention-days: 7
