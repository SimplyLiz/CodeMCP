name: NFR Tests

on:
  pull_request:
    branches: [develop, main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  nfr:
    name: NFR Scenarios
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Run NFR Tests
        id: nfr
        run: |
          # Run NFR tests
          set +e
          go test -v -run TestNFRScenarios ./internal/mcp/... 2>&1 | tee nfr-output.txt
          TEST_EXIT=${PIPESTATUS[0]}
          set -e

          # Parse results - count all PASS/FAIL lines including subtests
          PASS=$(grep -c -- "--- PASS" nfr-output.txt) || PASS=0
          FAIL=$(grep -c -- "--- FAIL" nfr-output.txt) || FAIL=0
          TOTAL=$((PASS + FAIL))

          # Job summary
          echo "## ðŸ“Š NFR Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| âœ… Passed | $PASS |" >> $GITHUB_STEP_SUMMARY
          echo "| âŒ Failed | $FAIL |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ“Š Total | $TOTAL |" >> $GITHUB_STEP_SUMMARY

          # Set outputs for PR comment
          echo "pass=$PASS" >> $GITHUB_OUTPUT
          echo "fail=$FAIL" >> $GITHUB_OUTPUT
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "exit_code=$TEST_EXIT" >> $GITHUB_OUTPUT

          exit $TEST_EXIT

      - name: Parse NFR metrics
        id: metrics
        if: always()
        run: |
          # Extract actual token counts and timings from test output
          # Format: tool_tier_actual_baseline_status

          cat > parse_nfr.py << 'EOF'
          import re

          def fmt_time(t):
              """Normalize timing: Âµs if <1ms, else ms"""
              t = t.strip()
              if "ms" in t and "Âµs" not in t:
                  return t  # already ms
              if "Âµs" in t:
                  val = float(t.replace("Âµs", ""))
                  if val >= 1000:
                      return f"{val/1000:.2f}ms"
                  return f"{val:.0f}Âµs"
              return t

          rows = []

          with open("nfr-output.txt", "r") as f:
              content = f.read()

          # Parse: "searchSymbols_small: 3500 bytes (baseline: 3600, max: 3960) [1.234ms]"
          pattern = r'(\w+)_(\w+): (\d+) bytes \(baseline: (\d+), max: (\d+)\) \[([^\]]+)\]'
          for match in re.finditer(pattern, content):
              tool, tier, actual, baseline, max_allowed, timing = match.groups()
              actual, baseline, max_allowed = int(actual), int(baseline), int(max_allowed)
              diff_pct = ((actual - baseline) / baseline) * 100
              budget_pct = (actual / max_allowed) * 100 if max_allowed > 0 else 0

              if diff_pct >= 10:
                  verdict = "FAIL"
              elif diff_pct >= 5:
                  verdict = "WARN"
              elif diff_pct <= -5:
                  verdict = "GOOD"
              else:
                  verdict = "OK"

              rows.append({
                  "tool": tool, "tier": tier, "actual": actual,
                  "baseline": baseline, "max": max_allowed,
                  "diff_pct": diff_pct, "budget_pct": budget_pct,
                  "timing": fmt_time(timing), "verdict": verdict
              })

          if rows:
              # Categorize
              fails = [r for r in rows if r["verdict"] == "FAIL"]
              warns = [r for r in rows if r["verdict"] == "WARN"]
              goods = [r for r in rows if r["verdict"] == "GOOD"]
              regressions = fails + warns
              savings = goods

              # Find highlights
              increases = [r for r in rows if r["diff_pct"] > 0]
              worst_reg = max(increases, key=lambda r: r["diff_pct"]) if increases else None
              best_impr = min(rows, key=lambda r: r["diff_pct"])
              hotspots = sorted([r for r in rows if r["budget_pct"] >= 90], key=lambda r: -r["budget_pct"])[:3]
              hotspot_count = sum(1 for r in rows if r["budget_pct"] >= 90)

              total = len(rows)
              oks = [r for r in rows if r["verdict"] == "OK"]
              passed = len(oks) + len(goods)

              # Headline with breakdown
              parts = []
              if fails:
                  parts.append(f"{len(fails)} failed")
              if warns:
                  parts.append(f"{len(warns)} regressed")
              parts.append(f"{passed} passed")
              if goods:
                  parts.append(f"ðŸ“‰ {len(goods)} improved")

              if fails:
                  print(f"## Response Size âŒ {' Â· '.join(parts)}\n")
              elif warns:
                  print(f"## Response Size âš ï¸ {' Â· '.join(parts)}\n")
              else:
                  print(f"## Response Size âœ… {' Â· '.join(parts)}\n")

              # Key metrics
              if worst_reg:
                  print(f"**Worst regression:** `{worst_reg['tool']}/{worst_reg['tier']}` **+{worst_reg['diff_pct']:.1f}%** ({worst_reg['actual']:,}B) â€¢ Budget {worst_reg['budget_pct']:.0f}%  ")
              else:
                  print("**Regressions:** none âœ…  ")
              print(f"**Best saving:** `{best_impr['tool']}/{best_impr['tier']}` **{best_impr['diff_pct']:.1f}%** ({best_impr['actual']:,}B) â€¢ Budget {best_impr['budget_pct']:.0f}%  ")
              if hotspots:
                  hs = ", ".join([f"`{h['tool']}/{h['tier']}` {h['budget_pct']:.0f}% (margin {100-h['budget_pct']:.0f}%)" for h in hotspots])
                  print(f"**Hotspots:** {hs}\n")
              else:
                  print("**Hotspots:** none â‰¥90% âœ…\n")

              # Summary counts
              reg_str = f"{len(fails)} FAIL / {len(warns)} WARN" if regressions else "0"
              print("| Regressions | Savings | Hotspots â‰¥90% | Scenarios |")
              print("|---:|---:|---:|---:|")
              print(f"| {reg_str} | {len(savings)} | {hotspot_count} | {total} |\n")

              # Diff block preview (top 3 each)
              preview_bad = sorted([r for r in rows if r["diff_pct"] >= 5], key=lambda r: -r["diff_pct"])[:3]
              preview_good = sorted([r for r in rows if r["diff_pct"] <= -5], key=lambda r: r["diff_pct"])[:3]

              if preview_bad or preview_good:
                  print("```diff")
                  for r in preview_bad:
                      print(f"- {r['verdict']:4} {r['tool']}/{r['tier']:<20} +{r['diff_pct']:5.1f}%  {r['actual']:>8,}B  budget {r['budget_pct']:>2.0f}%  {r['timing']}")
                  for r in preview_good:
                      print(f"+ GOOD {r['tool']}/{r['tier']:<20} {r['diff_pct']:+5.1f}%  {r['actual']:>8,}B  budget {r['budget_pct']:>2.0f}%  {r['timing']}")
                  print("```\n")

              # Regressions table
              if regressions:
                  print("### Regressions\n")
                  print("| Scenario | Actual (B) | Î” | Budget | Margin | Time | Verdict |")
                  print("|---|---:|---:|---:|---:|---:|---|")
                  for r in sorted(regressions, key=lambda x: -x["diff_pct"]):
                      v = f"**{r['verdict']}**" if r["verdict"] == "FAIL" else r["verdict"]
                      margin = 100 - r["budget_pct"]
                      print(f"| {r['tool']} / {r['tier']} | {r['actual']:,} | +{r['diff_pct']:.1f}% | {r['budget_pct']:.0f}% | {margin:.0f}% | {r['timing']} | {v} |")
                  print()

              # Savings table
              if savings:
                  print("### Savings\n")
                  print("| Scenario | Actual (B) | Î” | Budget | Margin | Time |")
                  print("|---|---:|---:|---:|---:|---:|")
                  for r in sorted(savings, key=lambda x: x["diff_pct"]):
                      margin = 100 - r["budget_pct"]
                      print(f"| {r['tool']} / {r['tier']} | {r['actual']:,} | {r['diff_pct']:.1f}% | {r['budget_pct']:.0f}% | {margin:.0f}% | {r['timing']} |")
                  print()

              # Full breakdown in details
              print("<details><summary>All scenarios</summary>\n")
              print("| Scenario | Actual (B) | Baseline | Max | Î” | Budget | Margin | Time |")
              print("|---|---:|---:|---:|---:|---:|---:|---:|")
              for r in sorted(rows, key=lambda x: -x["diff_pct"]):
                  margin = 100 - r["budget_pct"]
                  print(f"| {r['tool']} / {r['tier']} | {r['actual']:,} | {r['baseline']:,} | {r['max']:,} | {r['diff_pct']:+.1f}% | {r['budget_pct']:.0f}% | {margin:.0f}% | {r['timing']} |")
              print("\n</details>")
          else:
              print("No token metrics found in output")
          EOF

          if ! python3 parse_nfr.py > nfr-table.md 2>&1; then
            echo "::warning::Failed to parse NFR metrics"
            echo "No metrics parsed" > nfr-table.md
          fi
          cat nfr-table.md

      - name: Comment on PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let body = 'No NFR metrics available';
            try {
              body = fs.readFileSync('nfr-table.md', 'utf8');
            } catch (e) {}

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('NFR Budget')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Upload NFR results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: nfr-results
          path: |
            nfr-output.txt
            nfr-table.md
          retention-days: 7
