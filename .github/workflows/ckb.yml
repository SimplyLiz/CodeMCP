name: CKB Analysis

on:
  pull_request:
    branches: [develop, main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  analyze:
    name: PR Analysis
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for analysis

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Restore CKB Cache
        uses: actions/cache@v4
        with:
          path: .ckb/
          key: ckb-${{ runner.os }}-${{ github.base_ref }}-${{ hashFiles('go.sum') }}
          restore-keys: |
            ckb-${{ runner.os }}-${{ github.base_ref }}-
            ckb-${{ runner.os }}-

      - name: Build CKB
        run: go build -ldflags="-s -w" -o ckb ./cmd/ckb

      - name: Initialize CKB
        run: |
          ./ckb init
          if ! ./ckb index; then
            echo "::warning::Index generation failed, continuing with git-only analysis"
          fi

      - name: Analyze PR
        id: analyze
        run: |
          # Get PR analysis
          if ! ./ckb pr-summary --base=origin/${{ github.base_ref }} > pr-analysis.json 2>pr-analysis-err.txt; then
            echo "::warning::PR analysis failed"
            cat pr-analysis-err.txt
            echo '{"error": "analysis failed"}' > pr-analysis.json
          fi

          # Extract outputs
          RISK=$(jq -r '.riskAssessment.level // "unknown"' pr-analysis.json) || RISK="unknown"
          echo "risk_level=$RISK" >> $GITHUB_OUTPUT

          # Extract reviewers for auto-request
          jq -r '.suggestedReviewers // [] | .[0:3] | .[] | .owner' pr-analysis.json 2>/dev/null | \
            grep -v '^@' | tr '\n' ',' | sed 's/,$//' > reviewers.txt || true

      - name: Check Complexity
        id: complexity
        continue-on-error: true
        run: |
          echo '[]' > complexity-warnings.json
          WARNINGS='[]'

          for FILE in $(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '\.(go|ts|js|py)$' | head -20); do
            if [ -f "$FILE" ]; then
              RESULT=$(./ckb complexity "$FILE" 2>/dev/null || echo '{}')
              CYCLO=$(echo "$RESULT" | jq '.cyclomatic // 0')
              COGNITIVE=$(echo "$RESULT" | jq '.cognitive // 0')

              if [ "$CYCLO" -gt 15 ] 2>/dev/null; then
                WARNINGS=$(echo "$WARNINGS" | jq --arg f "$FILE" --arg c "$CYCLO" '. + [{"file": $f, "type": "cyclomatic", "value": ($c | tonumber)}]')
              fi
              if [ "$COGNITIVE" -gt 20 ] 2>/dev/null; then
                WARNINGS=$(echo "$WARNINGS" | jq --arg f "$FILE" --arg c "$COGNITIVE" '. + [{"file": $f, "type": "cognitive", "value": ($c | tonumber)}]')
              fi
            fi
          done

          echo "$WARNINGS" > complexity-warnings.json
          COUNT=$(echo "$WARNINGS" | jq 'length')
          echo "warning_count=$COUNT" >> $GITHUB_OUTPUT

      - name: Check Coupling
        id: coupling
        continue-on-error: true
        run: |
          echo '[]' > coupling-warnings.json
          CHANGED=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | tr '\n' ',' | sed 's/,$//')

          if [ -n "$CHANGED" ]; then
            ./ckb coupling --files="$CHANGED" --min-correlation=0.7 2>/dev/null > coupling-result.json || echo '{}' > coupling-result.json
            jq '.missingCoupled // []' coupling-result.json > coupling-warnings.json
          fi

          COUNT=$(jq 'length' coupling-warnings.json 2>/dev/null || echo 0)
          echo "warning_count=$COUNT" >> $GITHUB_OUTPUT

      - name: Comment on PR
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read all analysis data
            let prData = {};
            let complexityWarnings = [];
            let couplingWarnings = [];

            try { prData = JSON.parse(fs.readFileSync('pr-analysis.json', 'utf8')); } catch {}
            try { complexityWarnings = JSON.parse(fs.readFileSync('complexity-warnings.json', 'utf8')); } catch {}
            try { couplingWarnings = JSON.parse(fs.readFileSync('coupling-warnings.json', 'utf8')); } catch {}

            if (prData.error) {
              const body = '## CKB Analysis âš ï¸\n\nAnalysis failed: ' + prData.error;
              await postComment(body);
              return;
            }

            const s = prData.summary || {};
            const risk = prData.riskAssessment || {};
            const modules = prData.modulesAffected || [];
            const reviewers = prData.suggestedReviewers || [];
            const files = prData.changedFiles || [];

            // Risk styling
            const riskConfig = {
              high: { emoji: 'ðŸ”´', badge: '![Risk: High](https://img.shields.io/badge/Risk-High-red)' },
              medium: { emoji: 'ðŸŸ¡', badge: '![Risk: Medium](https://img.shields.io/badge/Risk-Medium-yellow)' },
              low: { emoji: 'ðŸŸ¢', badge: '![Risk: Low](https://img.shields.io/badge/Risk-Low-green)' }
            };
            const rc = riskConfig[risk.level] || { emoji: 'âšª', badge: '' };

            // Build comment sections
            let sections = [];

            // Header
            sections.push('## CKB Analysis ' + rc.emoji + ' **' + (risk.level || 'unknown').toUpperCase() + '**');
            sections.push('');

            // Summary table
            sections.push('| Metric | Value |');
            sections.push('|:-------|------:|');
            sections.push('| **Files** | ' + (s.totalFiles || 0) + ' |');
            sections.push('| **Additions** | +' + (s.totalAdditions || 0).toLocaleString() + ' |');
            sections.push('| **Deletions** | -' + (s.totalDeletions || 0).toLocaleString() + ' |');
            sections.push('| **Modules** | ' + (s.totalModules || 0) + ' |');
            sections.push('| **Hotspots** | ' + (s.hotspotsTouched || 0) + ' |');
            sections.push('');

            // Suggested reviewers (clickable @mentions)
            if (reviewers.length > 0) {
              sections.push('### ðŸ‘¥ Suggested Reviewers');
              sections.push('');
              const reviewerList = reviewers.slice(0, 4).map(r => {
                const name = r.owner.startsWith('@') ? r.owner : '@' + r.owner;
                const pct = Math.round((r.coverage || 0) * 100);
                return '| ' + name + ' | ' + pct + '% | ' + (r.reason || '') + ' |';
              });
              sections.push('| Reviewer | Coverage | Reason |');
              sections.push('|:---------|:--------:|:-------|');
              sections.push(reviewerList.join('\n'));
              sections.push('');
            }

            // Risk factors
            const factors = risk.factors || [];
            if (factors.length > 0) {
              sections.push('### âš ï¸ Risk Factors');
              sections.push('');
              factors.forEach(f => sections.push('- ' + f));
              sections.push('');
            }

            // Modules at risk
            const riskyModules = modules.filter(m => m.riskLevel === 'high' || m.riskLevel === 'medium').slice(0, 6);
            if (riskyModules.length > 0) {
              sections.push('<details>');
              sections.push('<summary><strong>ðŸ“¦ Modules at Risk (' + riskyModules.length + ')</strong></summary>');
              sections.push('');
              sections.push('| Module | Files | Risk |');
              sections.push('|:-------|------:|:-----|');
              riskyModules.forEach(m => {
                const emoji = m.riskLevel === 'high' ? 'ðŸ”´' : 'ðŸŸ¡';
                sections.push('| ' + emoji + ' `' + m.moduleId + '` | ' + m.filesChanged + ' | ' + m.riskLevel + ' |');
              });
              sections.push('');
              sections.push('</details>');
              sections.push('');
            }

            // Hotspots touched
            const hotspots = files.filter(f => f.isHotspot).slice(0, 5);
            if (hotspots.length > 0) {
              sections.push('<details>');
              sections.push('<summary><strong>ðŸ”¥ Hotspots Touched (' + hotspots.length + ')</strong></summary>');
              sections.push('');
              sections.push('| File | Score |');
              sections.push('|:-----|------:|');
              hotspots.forEach(f => {
                sections.push('| `' + f.path + '` | ' + (f.hotspotScore || 0).toFixed(2) + ' |');
              });
              sections.push('');
              sections.push('</details>');
              sections.push('');
            }

            // Complexity warnings
            if (complexityWarnings.length > 0) {
              sections.push('<details>');
              sections.push('<summary><strong>ðŸ“Š Complexity Warnings (' + complexityWarnings.length + ')</strong></summary>');
              sections.push('');
              sections.push('| File | Type | Value | Threshold |');
              sections.push('|:-----|:-----|------:|----------:|');
              complexityWarnings.forEach(w => {
                const threshold = w.type === 'cyclomatic' ? 15 : 20;
                sections.push('| `' + w.file + '` | ' + w.type + ' | **' + w.value + '** | ' + threshold + ' |');
              });
              sections.push('');
              sections.push('</details>');
              sections.push('');
            }

            // Coupling warnings
            if (couplingWarnings.length > 0) {
              sections.push('<details>');
              sections.push('<summary><strong>ðŸ”— Coupling Warnings (' + couplingWarnings.length + ')</strong></summary>');
              sections.push('');
              sections.push('These files usually change together but weren\'t included:');
              sections.push('');
              sections.push('| Missing File | Usually Changes With | Correlation |');
              sections.push('|:-------------|:---------------------|------------:|');
              couplingWarnings.slice(0, 5).forEach(w => {
                const pct = Math.round((w.couplingScore || 0) * 100);
                sections.push('| `' + w.file + '` | `' + w.coupledTo + '` | ' + pct + '% |');
              });
              sections.push('');
              sections.push('</details>');
              sections.push('');
            }

            const body = sections.join('\n');

            // Post or update comment
            async function postComment(content) {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });

              const botComment = comments.find(c => c.user.type === 'Bot' && c.body.includes('CKB Analysis'));

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: content
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: content
                });
              }
            }

            await postComment(body);

      - name: Auto-Request Reviewers
        if: always() && steps.analyze.outputs.risk_level != 'unknown'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            try {
              const data = JSON.parse(fs.readFileSync('pr-analysis.json', 'utf8'));
              const reviewers = (data.suggestedReviewers || [])
                .map(r => r.owner)
                .filter(r => !r.startsWith('@'))  // Filter out teams
                .filter(r => r !== context.actor)  // Don't request PR author
                .slice(0, 2);

              if (reviewers.length > 0) {
                console.log('Requesting reviewers:', reviewers);
                await github.rest.pulls.requestReviewers({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  reviewers: reviewers
                });
              }
            } catch (e) {
              console.log('Could not request reviewers:', e.message);
            }

      - name: Save CKB Cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .ckb/
          key: ckb-${{ runner.os }}-${{ github.base_ref }}-${{ hashFiles('go.sum') }}

      - name: Upload analysis
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ckb-analysis
          path: |
            pr-analysis.json
            pr-analysis-err.txt
            complexity-warnings.json
            coupling-warnings.json
          retention-days: 7
